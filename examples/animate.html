    <!DOCTYPE html>
    <html>
        <head>
            <title>Globe</title>

        <style type="text/css">
                html {height: 100%}
            body { margin: 0; overflow:hidden; height:100%}

                #viewerDiv {
                    margin : auto auto;
                    width: 100%;
                    height: 100%;
                    padding: 0;
                }
                #menuDiv {position: absolute; top:0px; margin-left: 0px;}
            </style>
            <meta charset="UTF-8">

            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.1/dat.gui.min.js"></script>
        </head>
        <body>
            <div id="viewerDiv"></div>
            <script src="/examples/GUI/GuiTools.js"></script>
            <script src="/dist/itowns.js"></script>
            <script src="/dist/debug.js"></script>
            <!-- from https://github.com/mrdoob/three.js/blob/master/examples/js/shaders/DotScreenShader.js -->

            <script type="x-shader/x-vertex" id="vertexshader">
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            </script>

            <script type="x-shader/x-fragment" id="fragmentshader">
                uniform vec2 center;
                uniform float angle;
                uniform float scale;
                uniform vec2 tSize;
                uniform float time;
                uniform vec2 screenSize;
                uniform vec2 pca;

                uniform sampler2D tDiffuse;
                uniform sampler2D tClasses;
                uniform sampler2D tClouds;

                varying vec2 vUv;

                vec4 color;
                float coefMix;
                float uvxSize; 
                float uvySize;



                #define M_PI 3.1415926535897932384626433832795

                // function return if class is water only
                bool checkWater(vec4 colorClasses, vec4 colorClassesDelta){

                    return 
                        colorClasses == vec4(0.,1.,0.,1.) && colorClassesDelta == vec4(0.,1.,0.,1.);

                    /*  colorClasses.g == 1. && colorClassesDelta.g == 1. &&
                        colorClasses.r <= 0.1 && colorClassesDelta.r <= 0.1 );
                     */
                }

                // Return true if color is building
                bool checkBuilding( vec4 color ){
                    return color.r == 1.;
                }

                // Return true if color is Road
                bool checkRoad( vec4 colorClasses, vec4 colorClassesDelta){
                   return (
                        colorClasses.b > 0.9 && colorClassesDelta.b > 0.9
                       // colorClasses.r <= 0.1 && colorClassesDelta.r <= 0.1
                         );
                }

                float getLuminance(vec4 color){
                    return (0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b);
                }

    /*
                // Return true if at least one neighbour is a building
                bool check8Connex(vec2 uv, sampler2D tex){

                    vec4 e0 = texture2D(tex, vec2(uv.x - 1, uv.y - 1));
                    vec4 e1 = texture2D(tex, vec2(uv.x - 0, uv.y - 1));
                    vec4 e2 = texture2D(tex, vec2(uv.x + 1, uv.y - 1));
                    vec4 e3 = texture2D(tex, vec2(uv.x - 1, uv.y - 0));
                    vec4 e4 = texture2D(tex, vec2(uv.x + 1, uv.y - 0));
                    vec4 e5 = texture2D(tex, vec2(uv.x - 1, uv.y + 1));
                    vec4 e6 = texture2D(tex, vec2(uv.x - 0, uv.y + 1));
                    vec4 e7 = texture2D(tex, vec2(uv.x + 1, uv.y + 1));

                    return checkBuilding(e0) || checkBuilding(e1) || checkBuilding(e2) || 
                           checkBuilding(e3) || checkBuilding(e4) || 
                           checkBuilding(e5) || checkBuilding(e6) || checkBuilding(e7);
                }

    */
                // This function compute distance between original pixel and other class object
                float checkDistanceToObstacle(vec2 uv, sampler2D tex){

                    const float maxDistance = 0.03;
                    float minDistance = maxDistance;

                    vec4 colorClassesDelta = texture2D( tex, uv);

                    if (!checkBuilding (colorClassesDelta)) {

                        for (float i = -maxDistance; i< maxDistance; i+= maxDistance / 10.) {

                            for (float j = -maxDistance; j< maxDistance; j+= maxDistance / 10.) {
                            
                                if (checkBuilding( texture2D(tex, vec2(uv.x + i, uv.y + j)) )){
                                    float dist = sqrt (i * i + j * j);
                                    if(dist < minDistance) minDistance = dist;
                                }
                            }
                        }

                    }

                    // We check if uv close to limits [0-1] to have nice opacity blending
                    //if (distance

                    return minDistance;
                }


                // Check distance from parameter uv to border of road
                float checkRoadBorders(vec2 uv, sampler2D tex){

                    const float maxDistance = 0.01;
                    float minDistance = maxDistance;

                    for (float i = -maxDistance; i< maxDistance; i+= maxDistance / 10.) {
                        for (float j = -maxDistance; j< maxDistance; j+= maxDistance / 10.) {
                        
                           if (texture2D(tex, vec2(uv.x + i, uv.y + j)).b != 1.){  // No road pixel
                                float dist = sqrt (i * i + j * j);
                                if(dist < minDistance) minDistance = dist;
                            }
                        }
                    }
                    return minDistance;
                }


                // For Road
                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxis(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 12.;
                    float d = 0.01;
                    const float incDistance = 0.002;
                    const float maxDistance = 0.1;
                    float currentMaxDist = 0.;
                    float angularOri = 0.;
                    vec2 outputVec = vec2(0.);

                    for (float i = 0.; i < M_PI; i += inc){

                        if(currentMaxDist >= maxDistance) break;    
                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){
                            vec2 currentCoord = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col = texture2D( tex, currentCoord);
                            bool inside = col.b == 1.;//col == colorClass;
                            if(a >= currentMaxDist) {currentMaxDist = a; angularOri = i; outputVec = vec2(cos(i), sin(i));}  
                            if (!inside) break;
                            //if(inside && a >=  maxDistance - incDistance) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }
                    return outputVec;
                }


                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxisWater(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 48.;
                    float d = 0.01;
                    const float incDistance = 0.004;
                    const float maxDistance = 0.2;
                    float angularOri = 0.;
                    vec2 outputVec = vec2(0.);

                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){
                            vec2 currentCoord = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            vec4 col = texture2D( tex, currentCoord);
                            bool inside = col.g == 1.;//col == colorClass;
                            if (!inside) break;
                            if(inside && a >= maxDistance * 0.9/*== maxDistance*/) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }

                    return outputVec;
                }


                // Returns the local axis of the object from class colorClass at coord uv
                vec2 getLocalObjectAxisWater2(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 48.;
                    float d = 0.01;
                    const float incDistance = 0.004;
                    const float maxDistance = 0.4;
                    vec2 outputVec = vec2(0.);
                    float distMinSeg = 0.02;
                    bool firstCoord = true;
                    vec2 p1 = vec2(0.);
                    vec2 p2 = vec2(0.);
                    bool founded = false;
                    float pivotIfOut = 0.;
                    bool relaunch = false;


                    for (float i = 0.; i < 2. * M_PI; i += inc){

                        if(founded || relaunch) break;
                        // Then we compute the max distance from the current position to the limit of the object
                        for (float a = 0.; a <= maxDistance; a += incDistance){

                            vec2 currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                            if(currentCoord.x > 1. || currentCoord.x < 0. || currentCoord.y > 1. || currentCoord.y < 0. || a >= maxDistance - incDistance && !founded){
                               // pivotIfOut = M_PI / 2.;
                                relaunch = true;
                                break;
                                //firstCoord = true;
                                //currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                            }else{
                                vec4 col = texture2D( tex, currentCoord);
                                bool inside = col.g == 1.;//col == colorClass;

                                if (!inside){
                                    if(firstCoord){ 
                                        firstCoord = false;
                                        p1 = currentCoord;
                                    }
                                    //p2 = currentCoord;
                                    if (distance(p2,p1) > distMinSeg){
                                        p2 = currentCoord;
                                        founded = true;
                                        break;
                                    } 
                                } 
                            }
                           // if(inside && a >= maxDistance * 0.9/*== maxDistance*/) {angularOri = i; outputVec = vec2(cos(i), sin(i)); break;}  
                        }
                    }

                    if(relaunch){

                        pivotIfOut = M_PI / 2.;
                        firstCoord = true;
                        founded = false;
                        for (float i = 0.; i < 2. * M_PI; i += inc){

                            if(founded) break;
                            // Then we compute the max distance from the current position to the limit of the object
                            for (float a = 0.; a <= maxDistance; a += incDistance){

                                vec2 currentCoord = vec2( uv.x + a * cos(i + pivotIfOut), uv.y + a * sin(i + pivotIfOut));
                                vec4 col = texture2D( tex, currentCoord);
                                bool inside = col.g == 1.;

                                if (!inside){
                                    if(firstCoord){ 
                                        firstCoord = false;
                                        p1 = currentCoord;
                                    }
                                    //p2 = currentCoord;
                                    if (distance(p2,p1) > distMinSeg){
                                        p2 = currentCoord;
                                        founded = true;
                                        break;
                                    } 
                                } 
                            }
                        }
                    }

                    outputVec = p2 - p1;

                    return outputVec;
                }


                  // Version 3 computing distance around point and returning perpedicular axis to minimum axis
                  // We turn around point to computing minimum distance.
                vec2 getLocalObjectAxisWater3(vec2 uv, sampler2D tex, vec4 colorClass){
                    
                    const float inc = M_PI / 32.;
                    float d;
                    const float incDistance = 0.01;
                    const float maxDistance = 0.12;
                    vec2 p1 = vec2(0.);
                    vec2 p2 = vec2(10.);
                    vec2 outVec = vec2(0.);
                    float distanceMin = 2.;

                    for (float i = 0.; i < M_PI; i += inc){

                        p1 = vec2(-10.);
                        p2 = vec2(10.);

                        // Look first extremity
                        for (float a = 0.; a <= maxDistance; a += incDistance){

                            vec2 currentCoord1 = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            if (currentCoord1.x > 0. && currentCoord1.x < 1. && currentCoord1.y > 0. && currentCoord1.y < 1.){
                                vec4 col1 = texture2D( tex, currentCoord1);
                                bool inside = col1.g == 1.;
                                if (!inside) {p1 = currentCoord1; break;}
                            }
                        }
                        // Look opposite extremity
                        for (float a = 0.; a >= -maxDistance; a -= incDistance){

                            vec2 currentCoord2 = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            if (currentCoord2.x > 0. && currentCoord2.x < 1. && currentCoord2.y > 0. && currentCoord2.y < 1.){
                                vec4 col2 = texture2D( tex, currentCoord2);
                                bool inside = col2.g == 1.;
                                if (!inside) {p2 = currentCoord2; break;}
                            }
                        }

                        // We compute length of segment
                        d = distance(p1,p2);//length(p2 - p1);
                        if(d < distanceMin){
                            distanceMin = d;
                            outVec = normalize(p2 - uv); //p2 - p1;
                        }

                    }

                    // Optional normalization at PI/4;
                    outVec = vec2(-outVec.x, outVec.y);  // Orthogonal vector
                    float alpha = atan(outVec.y, outVec.x);   // abs
                    //alpha = floor(alpha / (M_PI / 8.)) * (M_PI / 8.); 
                    //vec2 normalizedOutVec = vec2(cos(alpha), sin(alpha));

                    return vec2(alpha / ( M_PI), alpha / ( M_PI)); //normalizedOutVec; // vec2(-outVec.x, outVec.y);

                }

                // Fast version testing 8 axis
                vec2 getLocalObjectAxisWater4(vec2 uv, sampler2D tex, vec4 colorClass){

                    const float inc = M_PI / 4.;
                    float d;
                    const float incDistance = 0.005;
                    const float maxDistance = 0.12;
                    vec2 p1 = vec2(0.);
                    vec2 p2 = vec2(10.);
                    vec2 outVec = vec2(0.);
                    float distanceMin = .1;
                    float alphaMax = 0.;
                    bool founded = false;

                     for (float i = 0.; i < M_PI; i += inc){

                        for (float a = 0.; a <= maxDistance; a += incDistance){

                            if(founded) break;
                            vec2 currentCoord1 = vec2( uv.x + a * cos(i), uv.y + a * sin(i));
                            if (currentCoord1.x > 0. && currentCoord1.x < 1. && currentCoord1.y > 0. && currentCoord1.y < 1.){
                                vec4 col1 = texture2D( tex, currentCoord1);
                                bool inside = col1.g == 1.;
                                if (!inside) {p1 = currentCoord1; 
                                              if(a> distanceMin) {
                                                 alphaMax = i; 
                                                 founded = true;
                                              }
                                              break;}
                            }

                        }
                         if(founded) break;

                     }

                    vec2 normalizedOutVec = vec2(cos(alphaMax), sin(alphaMax));
                    return  normalizedOutVec; //vec2(alphaMax ,alphaMax); 
                }


                vec4 averageTexture(vec2 uv, sampler2D tex){

                    float uvxDistance = mod(uv.x, uvxSize); 
                    float uvyDistance = mod(uv.y, uvySize);
                    vec4 outColMixX = mix(texture2D( tex, uv), texture2D( tex, vec2(uv.x + uvxSize, uv.y)), uvxDistance / uvxSize);
                    vec4 outColMixY = mix(texture2D( tex, uv), texture2D( tex, vec2(uv.x, uv.y + uvySize)), uvyDistance / uvySize);
/*
                    float deltaUV = 0.001;
                    vec4 outCol = (texture2D( tex, vec2(uv.x + deltaUV, uv.y)) +  
                                   texture2D( tex, vec2(uv.x - deltaUV, uv.y)) + 
                                   texture2D( tex, vec2(uv.x, uv.y + deltaUV)) + 
                                   texture2D( tex, vec2(uv.x, uv.y - deltaUV)) + 
                                   texture2D( tex, uv)) / 5.;
*/
                    return (outColMixX + outColMixY) / 2.;
                }

                // Fast cheap color check (large interval) for vegetation
                bool lookLikeVegetation(vec4 col){
                    return col.g > col.r && col.r > col.b && col.g > 30./255. && col.g < 140./255.;
                }

                void main() {

                    float modTime = mod(time, 0.4);
                    float modVal = 0.04;
                    float motionDuration = 0.02; 
                    float speedCoefficient = 3.; 

                    vec2 nextUV = vec2( vUv.x * (1. - modTime), vUv.y /* * (1. - time) */);
                    vec2 nextUVCars; // = vec2( vUv.x /* * (1. - time * 3.)*/, vUv.y * (1. - modTime *  3.) );

                    vec4 currentColor = texture2D( tDiffuse, vUv);
                    vec4 colorClasses = texture2D( tClasses, vUv );
                    vec4 colorClassesDelta;
                    vec4 colorClassesDeltaCars;

                    float minDistance = 0.; //0.03; // checkDistanceToObstacle(nextUV, tClasses);
                    vec2 axis = vec2(0., 0.);
                    float distBlendingBorder = 0.02;

                    color = currentColor;

                    uvxSize = 1. / screenSize.x;
                    uvySize = 1. / screenSize.y;

                    // Large interval because we suppose we're on a road
                    // We could also compute a score based on the distance to the interval
                    //bool indiceVegetation = currentColor.g > currentColor.r && currentColor.r > currentColor.b && currentColor.g > 30./255. && currentColor.g < 140./255.;
                    //if (indiceVegetation) colorClasses = vec4(1.,1.,1.,1.);



                    if(colorClasses.b  == 1. && ! lookLikeVegetation(currentColor)){           // ROAD
                        axis = getLocalObjectAxis(vUv, tClasses, vec4(0., 0., 1., 1.));
                        float mD =  mod(time, 2. * motionDuration) - motionDuration;
                        float timeCoef = mD > 0. ? mD : -mD;
                        nextUVCars = vUv +  timeCoef/*mod(time, motionDuration)*/ * axis * speedCoefficient; // vec2( mod(axis.x * modTime * 4., modVal), mod(axis.y * modTime * 4., modVal)); //vUv + 4. * axis * modTime;
                        //nextUVCars = vec2( vUv.x * (1. + axis.x * modTime*4.), vUv.y  * (1. + axis.y * modTime*4.) );
                        colorClassesDeltaCars = texture2D(tClasses, nextUVCars);
                        if(colorClassesDeltaCars.b == 1. && ! lookLikeVegetation(texture2D( tDiffuse, nextUVCars))){
                            color = averageTexture(nextUVCars, tDiffuse); //minDistance = 1.; //texture2D( tDiffuse, nextUVCars); minDistance = 1.;
                        }
                        float distToBorders = checkRoadBorders(vUv/*nextUVCars*/, tClasses);
                        color = mix(color, currentColor, 1. - min(distToBorders * 300., 1.));

                    }else{

                        if(colorClasses.r == 1.){        // BUILDING
                            // We don't need to do anything
                        }else

                            if(colorClasses.g == 1.){    // WATER
                                axis =  pca; // getLocalObjectAxisWater4(vUv, tClasses, vec4(0., 1., 0., 1.));
                                //nextUV = vUv + mod(time, 0.1) * axis;
                                vec2 uvTraj = vUv + mod(time, 0.1) * axis;
                                vec2 perioNoise = vec2( mod(uvTraj.x, 0.001 ),  mod(uvTraj.y, 0.001 ));
                                nextUV = uvTraj + perioNoise; //vUv + mod(time, 0.1) * axis + mod(vUv.y, 0.001); //mod(sqrt(axis.x * vUv.x + axis.y * vUv.y), 0.001);//mod(vUv.x, 0.001); // We introduce a periodic effect to have different speed on each pixel
                                /*
                                if(uvC < 0.001){
                                    //nextUV = vUv + mod(time, 0.1) * axis;
                                }else
                                   nextUV = vUv + mod(time, 0.1) * axis;
                                   */
                                //vec2(vUv.x * (1. + axis.x / 10. + modTime), vUv.y * (1. + axis.y / 10. + modTime)  ); //vUv + vec2( mod(axis.x + modTime , 0.04), mod(axis.y + modTime , 0.04)); //vUv + vec2( mod(axis.x * modTime * 0.2, modVal), mod(axis.y * modTime * 0.2, modVal));//vec2( mod(axis.x + modTime , 0.04), mod(axis.y + modTime , 0.04)); //vec2(vUv.x * (axis.x + modTime), vUv.y )
                                colorClassesDelta = texture2D( tClasses, nextUV);
                                vec4 nextTexture;
                                if(nextUV.x > 1. || nextUV.y > 1. || nextUV.x < 0. || nextUV.y < 0.)
                                   nextTexture =  color;
                                else
                                   nextTexture = averageTexture(nextUV, tDiffuse); // texture2D( tDiffuse, nextUV);
                                
                                if( colorClassesDelta == vec4(0., 1., 0., 1.)) {  // if it is only water
                                    minDistance = checkDistanceToObstacle(nextUV, tClasses);  // Check obstacle and also end of texture (uv.x> 1 for example)
                                    color = mix(currentColor, nextTexture, min(minDistance * (1. / 0.03), 1.) );
                                }

                                // We test if close to limit of frame uv to have smooth progressive blending on boarders
                                if(nextUV.x + distBlendingBorder > 1. ){ //|| nextUV.y > 1. || nextUV.x < 0. || nextUV.y < 0.){
                                    color = mix(color, currentColor, 1. / distBlendingBorder * (nextUV.x + distBlendingBorder - 1.)); // vec4( 20. * (nextUV.x + distBlendingBorder - 1.),0.,0.,1.);
                                }
                                if(nextUV.y - distBlendingBorder < 0. ){ //|| nextUV.y > 1. || nextUV.x < 0. || nextUV.y < 0.){
                                    color = mix(color, currentColor, 1. / distBlendingBorder * ( distBlendingBorder - nextUV.y)); // vec4( 20. * (nextUV.x + distBlendingBorder - 1.),0.,0.,1.);
                                }
                            /*
                                // Specular effect like wave
                                float uvC = abs(0.01 - mod(time * 10., .01) - mod(vUv.x, 0.01));
                                if(getLuminance(color) > 0.3){
                                    if(uvC < 0.001) color *= 1. + (0.001 - uvC) * 100.;
                                }
                            */
                            }
                        }

                    // CLOUDS
                    vec4 cloudColor = texture2D(tClouds, vec2( vUv.x + 1. * time, vUv.y + 1. * time) );
                    color = mix(color, vec4(cloudColor.r,cloudColor.r,cloudColor.r,1.), cloudColor.r - 0.1);  // -0.1 to erase "noise"    

                    gl_FragColor =   colorClasses; //color; //vec4( abs(axis.x) , abs(axis.y) , 0., 1.); // color; // mix(color, colorClasses, 0.5); // color; // vec4(vec2( abs(axis.x) * 5., abs(axis.y) * 5.), 0., 1.);// color; //vec4(vec2( abs(axis.x) * 5., abs(axis.y) * 5.), 0., 1.);//color; // mix(color, colorClasses, 0.5); //vec4(vec3(minDistance * 100.), 1.); //color; // colorClasses

                }

/*

                    if(colorClasses.b  == 1.){   // ROAD
                        axis = getLocalObjectAxis(vUv, tClasses, vec4(0., 0., 1., 1.));
                        nextUVCars = vUv + vec2( mod(axis.x * modTime * 4., 0.02), mod(axis.y * modTime * 4., 0.02));//vUv + 4. * axis * modTime;
                        //nextUVCars = vec2( vUv.x * (1. + axis.x * modTime*4.), vUv.y  * (1. + axis.y * modTime*4.) );
                        colorClassesDeltaCars = texture2D( tClasses, nextUVCars);
                        nextColorCars = texture2D( tDiffuse, nextUVCars);
                    }


                    if (colorClasses.g == 1.){  // checkWater( colorClasses, colorClassesDelta)){  // WATER
                        axis =  getLocalObjectAxisWater(vUv, tClasses, vec4(0., 1., 0., 1.));
                        nextUV = vUv + vec2( mod(axis.x + modTime , 0.04), mod(axis.y + modTime , 0.04));//vec2(vUv.x * (axis.x + modTime), vUv.y )//vUv + vec2( mod(axis.x * modTime , 0.04), mod(axis.y * modTime , 0.04));//vUv + 4. * axis * modTime;

                        if( texture2D( tClasses, nextUV) == vec4(0., 1., 0., 1.)) {  // if it is only water
                            color = texture2D( tDiffuse, nextUV);
                            minDistance = checkDistanceToObstacle(nextUV, tClasses);
                        } else color = currentColor;
                    }
                    else
                        if (checkRoad( colorClasses, colorClassesDeltaCars)){
                            color = nextColorCars; minDistance = 1.;//vec4(0.,0.,1.,1.); nextColor;
                        }
                        else
                            color = currentColor;

                    color = mix(currentColor, color,  min(minDistance * (1. / 0.03), 1.) ); // vec4(vec3(minDistance * (1./ 0.03)), 1.); // vec4(axis, 1., 1.);//


                    gl_FragColor = color; // mix(color, colorClasses, 0.5); //vec4(vec3(minDistance * 100.), 1.); //color; // colorClasses

                   // if(axis.x > 0.9 || axis.x < - 0.9) gl_FragColor = vec4(1., 1., 1., 1.);
                   // if(axis.y > 0.9 || axis.y < - 0.9) gl_FragColor = vec4(1., 0., 1., 1.);
                }
*/
            </script>

            <script type="text/javascript">
                /* global itowns,document,GuiTools*/

                const positionOnGlobe = { longitude: 2.351323, latitude: 48.856712, altitude: 1000 };

                // iTowns namespace defined here
                const viewerDiv = document.getElementById('viewerDiv');

                const menuGlobe = new GuiTools('menuDiv');
                const globeView = new itowns.GlobeView(viewerDiv, positionOnGlobe);
                menuGlobe.view = globeView;

                itowns.Fetcher.json('layers/JSONLayers/Ortho.json').then(result => {globeView.addLayer(result);
                   itowns.Fetcher.json('layers/JSONLayers/Hydro.json').then(result => { globeView.addLayer(result);
                     itowns.Fetcher.json('layers/JSONLayers/Batiments.json').then(result => {globeView.addLayer(result);
                          itowns.Fetcher.json('layers/JSONLayers/Roads.json').then(result => globeView.addLayer(result))
                    })
                  })
               });

                menuGlobe.addGUI('RealisticLighting', false,
                    (newValue) => { globeView.setRealisticLightingOn(newValue); });

                globeView.addEventListener(itowns.GLOBE_VIEW_EVENTS.GLOBE_INITIALIZED, () => {
                    // eslint-disable-next-line no-console
                    console.info('Globe initialized');
                    menuGlobe.addImageryLayersGUI(globeView.getLayers(l => l.type === 'color'));
                    menuGlobe.addElevationLayersGUI(globeView.getLayers(l => l.type === 'elevation'));
                });


                 menuGlobe.addGUI('Classification', false,
                    (newValue) => { globeView.setClassificationOn(newValue); });



                // Simple postprocessing setup
                //
                const postprocessScene = new itowns.THREE.Scene();
                const quad = new itowns.THREE.Mesh( new itowns.THREE.PlaneBufferGeometry( 2, 2 ), null);
                quad.frustumCulled = false;
                quad.material = new itowns.THREE.ShaderMaterial( {
                    uniforms: {
                        "tDiffuse": { value: null },  // Original image (with optional dection output debug) 
                        "tClasses": { value: null },  // Classes image (one color per object class (layer))
                        "tClouds":  { value: new itowns.THREE.TextureLoader().load( "cloud.jpg" ) },  // Original image (with optional dection output debug) 
                        "tSize":    { value: new itowns.THREE.Vector2( 256, 256 ) },
                        "screenSize": { value: new itowns.THREE.Vector2( globeView.mainLoop.gfxEngine.getWindowSize().x,  globeView.mainLoop.gfxEngine.getWindowSize().y ) },
                        "center":   { value: new itowns.THREE.Vector2( 0.5, 0.5 ) },
                        "angle":    { value: 1.57 },
                        "scale":    { value: 1.0 },
                        "time":     { value: 0.  },
                        "pca":      { value: new itowns.THREE.Vector2() },
                    },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                } );
                postprocessScene.add(quad);
                const cam = new itowns.THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);



                globeView.render = () => {

                    const g = globeView.mainLoop.gfxEngine;
                    const r = g.renderer;
                    r.setRenderTarget(g.fullSizeRenderTarget);
                    r.clear();
                    r.setViewport(0, 0, g.getWindowSize().x, g.getWindowSize().y);

                // RENDER NORMAL IMAGERY
                    r.render(
                        globeView.scene,
                        globeView.camera.camera3D, g.fullSizeRenderTarget);
                    //var t0 = performance.now();
                    r.readRenderTargetPixels( g.fullSizeRenderTarget, 0, 0, g.getWindowSize().x, g.getWindowSize().y, globeView.arrayRTT );
                    globeView.rttTexture.needsUpdate = true;


                // RENDER ONLY OBJECT CLASSES (layer)
                    globeView.setClassesOnly(true);
                    r.setRenderTarget(g.fullSizeRenderTargetCLASSES);
                    r.clear();
                    r.render(
                        globeView.scene,
                        globeView.camera.camera3D, g.fullSizeRenderTargetCLASSES);
                    //var t0 = performance.now();
                    r.readRenderTargetPixels( g.fullSizeRenderTargetCLASSES, 0, 0, g.getWindowSize().x, g.getWindowSize().y, globeView.arrayRTTCLASSES );
                    globeView.rttTextureCLASSES.needsUpdate = true;
                    globeView.setClassesOnly(false);
                            // const gl = g.renderer.context;
                            // var fb = gl.createFramebuffer();
                            // gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                            // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                            // gl.readPixels( 0, 0, g.getWindowSize().x, g.getWindowSize().y, gl.RGBA, gl.G_HALF_FLOAT, globeView.arrayRTT );

                // OPTIONAL CLASSIFICATION PHASE            
                    var cvTexture;
                    //var t1 = performance.now();   

                    if(globeView.classificationOn && globeView.mainLoop.needsRedraw){
                        var segmentation = new itowns.Segmentation();
                        segmentation.setImage(globeView.rttTexture, globeView.rttTextureCLASSES);//g.fullSizeRenderTarget);
                        globeView.pca = segmentation.computePCA(1); //console.log(globeView.pca);
                        //cvTexture = segmentation.extractCars(); cvTexture = segmentation.computePCA(1);
                    } /*else
                        cvTexture = globeView.rttTexture;*/
                    //var t2 = performance.now();
                    // console.log(t1 - t0,"  ",t2-t1);
                    

                    // SOBEL pass 
                    if(globeView.classificationOn && globeView.mainLoop.needsRedraw){
                        var segmentation2 = new itowns.Segmentation();
                       // globeView.arrayRTTCLASSES = segmentation2.sobelPass(globeView.rttTexture);

                        globeView.rttTextureCLASSES = new itowns.THREE.DataTexture(segmentation2.sobelPass(globeView.rttTexture),
                             g.getWindowSize().x, g.getWindowSize().y, itowns.THREE.RGBAFormat);
                        globeView.rttTextureCLASSES.needsUpdate = true;
                    }



                    cvTexture = globeView.rttTexture;

                    quad.material.uniforms["tDiffuse"].value = cvTexture;//g.fullSizeRenderTarget.texture;
                    quad.material.uniforms["tClasses"].value = globeView.rttTextureCLASSES;//g.fullSizeRenderTarget.texture;
                    quad.material.uniforms["time"].value += 0.00008;
                    quad.material.uniforms["pca"].value = globeView.pca;
                            // quad.material.uniforms["tSize"].value.set(
                            // g.fullSizeRenderTarget.width, g.fullSizeRenderTarget.height);

                    r.setRenderTarget();
                    r.clear();
                    r.setViewport(0, 0, g.getWindowSize().x, g.getWindowSize().y);
                    r.render(
                        postprocessScene,
                        cam);
                };


                // Force render each frame (dirty mode)
                forceRender = function () {
                     
                        requestAnimationFrame(forceRender);
                        globeView.render();
                };

                forceRender();
                

    </script>
        </body>
    </html>
